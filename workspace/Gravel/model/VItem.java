package model;

import model.Messages.GraphConstraints;

import java.awt.*;
import java.util.Comparator;

/**
 * Abstract superclass for both nodes and edges wdich contains the similar stuff for both
 *
 * @author Ronny Bergmann
 * @since Gravel 0.2.3
 */
public abstract class VItem {

  public static class IndexComparator implements Comparator<VItem> {
    public int compare(VItem a, VItem b) {
      if (a.getIndex() < b.getIndex())
        return -1;
      if (a.getIndex() == b.getIndex())
        return 0;
      else // >
        return 1;
    }

    public boolean equals(VItem a, VItem b) {
      return a.getIndex() == b.getIndex();
    }
  }

  //Definetly not selected
  public final static int DESELECTED = 0;
  //Just ATM not selected e.g. while you drag a mouse or sth like that
  public final static int SOFT_DESELECTED = 1;
  //Definetly selected
  public final static int SELECTED = 2;
  //Just ATM selected e.g. while you drag a mouse or sth like that
  public final static int SOFT_SELECTED = 4;

  public final static int EDGE = GraphConstraints.EDGE;
  public final static int HYPEREDGE = GraphConstraints.HYPEREDGE;
  public final static int NODE = GraphConstraints.NODE;

  private int status;

  private int index;  //Key of the VItem

  private Color colour; //Color of Element
  private int setCount; //Number of Sets, this Item belngs to (needed for computaion of next color)

  /**
   * Standard Constructor that initializes the VItem with a specific index and
   * sets the new Item to Deselected
   *
   * @param i index of the VItem
   */
  public VItem(int i) {
    index = i;
    status = DESELECTED;
    setCount = 0;
    colour = Color.black;
  }

  /**
   * Set Index of the item to a new value
   * <p>
   * ATTENTION: This Method should be called only if really needed
   * The Index is the main element for references (e.g. to adjacent nodes of an edge)
   * Therefore only use this Method if you're sure you don't mess the Graph
   *
   * @param index the index to set
   */
  protected void setIndex(int index) {
    this.index = index;
  }

  /**
   * Get Index of this Item
   *
   * @return the index
   */
  public int getIndex() {
    return index;
  }

  /**
   * get actual Color of the Edge that is generated by the VSubgraphs the Edge is in
   *
   * @return the actual color
   */
  public Color getColor() {
    return colour;
  }

  /**
   * if an edge is added to a VSubgraph the VSubgraphs color is added here.
   *
   * @param newc color of the VSubgraph the edge was added to
   */
  public void addColor(Color newc) {
    int b = colour.getBlue() * setCount + newc.getBlue();
    int a = colour.getAlpha() * setCount + newc.getAlpha();
    int g = colour.getGreen() * setCount + newc.getGreen();
    int r = colour.getRed() * setCount + newc.getRed();
    setCount++;
    colour = new Color((r / setCount), (g / setCount), (b / setCount), (a / setCount));
  }

  /**
   * if an edge is removed from a subgraph the color must be removed too
   *
   * @param newc color of the VSubgraph the edge was removed from
   */
  public void removeColor(Color newc) {
    if (setCount > 1) {
      int b = colour.getBlue() * setCount - newc.getBlue();
      int a = colour.getAlpha() * setCount - newc.getAlpha();
      int g = colour.getGreen() * setCount - newc.getGreen();
      int r = colour.getRed() * setCount - newc.getRed();
      //Durch Rundungsfehler k√∂nnen dabei negative werte entstehen, diese also verhindern
      if (b < 0) b = 0;
      if (a < 0) a = 0;
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      setCount--;
      colour = new Color((r / setCount), (g / setCount), (b / setCount), (a / setCount));
    } else {
      colour = Color.black;
      setCount = 0;
    }
  }

  /**
   * Copy the Color Situation (Color and setCount) to parameter and
   *
   * @param m
   * @return the modified parameter
   */
  public VItem copyColorStatus(VItem m) {
    m.colour = colour;
    m.setCount = setCount;
    return m;
  }

  /**
   * Set the status to a given Value, use || to set it to multiple ones
   *
   * @param s
   */
  public void setSelectedStatus(int s) {
    status = s;
  }

  /**
   * reset to the nonselected Standard
   */
  public void deselect() {
    status = DESELECTED;
  }

  /**
   * get the actual Status of the Item
   *
   * @return the status
   */
  public int getSelectedStatus() {
    return status;
  }

  /**
   * Get the Selected Status of the Item
   * Deprecated since the VItem Stuff
   *
   * @return true if the Item is Selected, else false
   * @deprecated
   */
  public boolean isSelected() {
    return ((status & SELECTED) == SELECTED);
  }

  /**
   * Setselected - deprecated since the VItem Stuff
   *
   * @deprecated
   */
  public void select() {
    status = SELECTED;
  }

  /**
   * Get the Type of this VItem - see final values above
   *
   * @return type of VItem
   */
  public abstract int getType();
}
